import { useEffect, useState } from 'react';
import { Card, Layout, Menu, Button, Space, message, Modal, Form, Input, Select, Steps } from 'antd';
import {
  SaveOutlined,
  ImportOutlined,
  ExportOutlined,
  UndoOutlined,
  RedoOutlined,
  ZoomInOutlined,
  ZoomOutOutlined,
  OneToOneOutlined,
  PlayCircleOutlined,
} from '@ant-design/icons';
import LogicFlow from '@logicflow/core';
import { DndPanel, SelectionSelect, Control, MiniMap } from '@logicflow/extension';
import { nodeDefinitions } from './nodes';
import '@logicflow/core/dist/index.css';
import '@logicflow/extension/lib/style/index.css';
import './index.css';
import type { DndPanel as DndPanelType } from '@logicflow/extension';

const { Sider, Content } = Layout;
const { Option } = Select;

// ËäÇÁÇπÁ±ªÂûãÂÆö‰πâ
const nodeTypes = [
  { type: 'start', label: 'ÂºÄÂßãËäÇÁÇπ', icon: '‚≠ï' },
  { type: 'approval', label: 'ÂÆ°ÊâπËäÇÁÇπ', icon: 'üìù' },
  { type: 'condition', label: 'Êù°‰ª∂ËäÇÁÇπ', icon: '‚ùì' },
  { type: 'parallel', label: 'Âπ∂Ë°åËäÇÁÇπ', icon: '‚ö°' },
  { type: 'end', label: 'ÁªìÊùüËäÇÁÇπ', icon: 'üîö' },
];

interface ProcessDesignerProps {
  processKey?: string;
  onSave?: (data: any) => void;
}

interface GraphNode {
  id: string;
  type: string;
  properties?: {
    name?: string;
    [key: string]: any;
  };
}

interface GraphEdge {
  id: string;
  sourceNodeId: string;
  targetNodeId: string;
  type: string;
  properties?: Record<string, any>;
}

interface GraphData {
  nodes: GraphNode[];
  edges: GraphEdge[];
}

interface SimulationStep {
  node: GraphNode;
  status: 'wait' | 'process' | 'finish' | 'error';
  title: string;
  description: string;
}

const ProcessDesigner: React.FC<ProcessDesignerProps> = ({ processKey, onSave }) => {
  const [lf, setLf] = useState<LogicFlow>();
  const [nodeModalVisible, setNodeModalVisible] = useState(false);
  const [currentNode, setCurrentNode] = useState<any>(null);
  const [nodeForm] = Form.useForm();
  const [simulationVisible, setSimulationVisible] = useState(false);
  const [currentStep, setCurrentStep] = useState(0);
  const [simulationPath, setSimulationPath] = useState<any[]>([]);

  // ÂàùÂßãÂåñÊµÅÁ®ãËÆæËÆ°Âô®
  useEffect(() => {
    // ÂàùÂßãÂåñ LogicFlow
    LogicFlow.use(DndPanel);
    LogicFlow.use(SelectionSelect);
    LogicFlow.use(Control);
    LogicFlow.use(MiniMap);

    const logicflow = new LogicFlow({
      container: document.querySelector('#process-designer') as HTMLElement,
      grid: true,
      nodeTextEdit: true,
      nodeTextDraggable: true,
      adjustEdge: true,
      adjustNodePosition: true,
      dragOnConnecting: true,
      style: {
        rect: {
          radius: 5,
          strokeWidth: 2,
        },
        circle: {
          r: 25,
          strokeWidth: 2,
        },
        nodeText: {
          overflowMode: 'autoWrap',
          fontSize: 12,
        },
        edgeText: {
          textWidth: 100,
          fontSize: 12,
          background: {
            fill: '#fff',
          },
        },
      },
    });

    // Ê≥®ÂÜåËá™ÂÆö‰πâËäÇÁÇπ
    Object.values(nodeDefinitions).forEach(node => {
      logicflow.register(node);
    });

    // ÁõëÂê¨ËäÇÁÇπÁÇπÂáª‰∫ã‰ª∂
    logicflow.on('node:click', ({ data }) => {
      setCurrentNode(data);
      nodeForm.setFieldsValue(data.properties);
      setNodeModalVisible(true);
    });

    // Ê∑ªÂä†ÊãñÊãΩÁõ∏ÂÖ≥‰∫ã‰ª∂ÁõëÂê¨
    logicflow.on('node:dragstart', () => {
      logicflow.updateEditConfig({ stopMoveGraph: true });
    });

    logicflow.on('node:dragend', () => {
      logicflow.updateEditConfig({ stopMoveGraph: false });
    });

    logicflow.on('connection:not-allowed', (data: any) => {
      message.error('Êó†Ê≥ïÂª∫Á´ãÊ≠§ËøûÊé•');
    });

    setLf(logicflow);

    // Â¶ÇÊûúÊúâprocessKeyÔºåÂä†ËΩΩÂ∑≤ÊúâÊµÅÁ®ã
    if (processKey) {
      // TODO: Âä†ËΩΩÊµÅÁ®ãÊï∞ÊçÆ
    }

    return () => {
      logicflow.destroy();
    };
  }, [processKey]);

  // Â∑•ÂÖ∑Ê†èÊìç‰Ωú
  const handleUndo = () => lf?.undo();
  const handleRedo = () => lf?.redo();
  const handleZoomIn = () => lf?.zoom(true);
  const handleZoomOut = () => lf?.zoom(false);
  const handleResetZoom = () => lf?.resetZoom();

  // ‰øùÂ≠òÊµÅÁ®ã
  const handleSave = () => {
    if (!lf) return;
    const data = lf.getGraphData();
    onSave?.(data);
    message.success('‰øùÂ≠òÊàêÂäü');
  };

  // ÂØºÂÖ•ÊµÅÁ®ã
  const handleImport = () => {
    Modal.confirm({
      title: 'ÂØºÂÖ•ÊµÅÁ®ã',
      content: 'Á°ÆÂÆöË¶ÅÂØºÂÖ•Êñ∞ÁöÑÊµÅÁ®ãÊï∞ÊçÆÂêóÔºüËøôÂ∞ÜË¶ÜÁõñÂΩìÂâçÁîªÂ∏ÉÁöÑÂÜÖÂÆπ„ÄÇ',
      onOk: () => {
        // TODO: ÂÆûÁé∞ÂØºÂÖ•ÂäüËÉΩ
        message.success('ÂØºÂÖ•ÊàêÂäü');
      },
    });
  };

  // ÂØºÂá∫ÊµÅÁ®ã
  const handleExport = () => {
    if (!lf) return;
    const data = lf.getGraphData();
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `process-${Date.now()}.json`;
    link.click();
    URL.revokeObjectURL(url);
    message.success('ÂØºÂá∫ÊàêÂäü');
  };

  // Êõ¥Êñ∞ËäÇÁÇπÂ±ûÊÄß
  const handleUpdateNode = (values: any) => {
    if (!lf || !currentNode) return;
    lf.setProperties(currentNode.id, values);
    setNodeModalVisible(false);
    nodeForm.resetFields();
  };

  // ÂºÄÂßãÊ®°ÊãüËøêË°å
  const handleStartSimulation = () => {
    if (!lf) return;
    const data = lf.getGraphData() as GraphData;
    
    // Êü•ÊâæÂºÄÂßãËäÇÁÇπ
    const startNode = data.nodes.find(node => node.type === 'start');
    if (!startNode) {
      message.error('ÊµÅÁ®ã‰∏≠ÂøÖÈ°ªÂåÖÂê´ÂºÄÂßãËäÇÁÇπ');
      return;
    }

    // ÂàùÂßãÂåñÊ®°ÊãüË∑ØÂæÑ
    setSimulationPath([{
      node: startNode,
      status: 'process',
      title: 'ÂºÄÂßãËäÇÁÇπ',
      description: 'ÊµÅÁ®ãÂºÄÂßã'
    }]);
    setCurrentStep(0);
    setSimulationVisible(true);
  };

  // Â§ÑÁêÜËäÇÁÇπÈÄâÊã©
  const handleNodeSelect = (nodeId: string) => {
    if (!lf) return;
    const data = lf.getGraphData() as GraphData;
    
    // Ëé∑ÂèñÂΩìÂâçËäÇÁÇπÁöÑÂá∫Ëæπ
    const edges = data.edges.filter(edge => edge.sourceNodeId === nodeId);
    const currentNode = data.nodes.find(node => node.id === nodeId);
    
    if (!currentNode) return;
    
    // Â¶ÇÊûúÊòØÁªìÊùüËäÇÁÇπÔºåÂÆåÊàêÊ®°Êãü
    if (currentNode.type === 'end') {
      setSimulationPath(prev => [
        ...prev,
        {
          node: currentNode,
          status: 'finish',
          title: 'ÁªìÊùüËäÇÁÇπ',
          description: 'ÊµÅÁ®ãÁªìÊùü'
        }
      ]);
      message.success('ÊµÅÁ®ãÊ®°ÊãüÂÆåÊàê');
      return;
    }
    
    // Â¶ÇÊûúÊúâÂ§ö‰∏™Âá∫ËæπÔºàÊù°‰ª∂ÊàñÂπ∂Ë°åÔºâÔºåÊòæÁ§∫ÈÄâÊã©ÂØπËØùÊ°Ü
    if (edges.length > 1) {
      Modal.confirm({
        title: 'ÈÄâÊã©‰∏ã‰∏ÄÊ≠•',
        content: (
          <Select
            style={{ width: '100%' }}
            onChange={(value) => {
              const nextNode = data.nodes.find(node => node.id === value);
              if (nextNode) {
                setSimulationPath(prev => [
                  ...prev,
                  {
                    node: nextNode,
                    status: 'process',
                    title: nextNode.properties?.name || nextNode.type,
                    description: `ÊâßË°å${nextNode.type === 'condition' ? 'Êù°‰ª∂Âà§Êñ≠' : 'ËäÇÁÇπ‰ªªÂä°'}`
                  }
                ]);
                setCurrentStep(prev => prev + 1);
              }
            }}
          >
            {edges.map(edge => {
              const targetNode = data.nodes.find(node => node.id === edge.targetNodeId);
              return (
                <Select.Option key={targetNode?.id} value={targetNode?.id}>
                  {targetNode?.properties?.name || targetNode?.type}
                </Select.Option>
              );
            })}
          </Select>
        ),
      });
    } else if (edges.length === 1) {
      // Â¶ÇÊûúÂè™Êúâ‰∏Ä‰∏™Âá∫ËæπÔºåÁõ¥Êé•ËøõÂÖ•‰∏ã‰∏ÄËäÇÁÇπ
      const nextNode = data.nodes.find(node => node.id === edges[0].targetNodeId);
      if (nextNode) {
        setSimulationPath(prev => [
          ...prev,
          {
            node: nextNode,
            status: 'process',
            title: nextNode.properties?.name || nextNode.type,
            description: `ÊâßË°å${nextNode.type === 'condition' ? 'Êù°‰ª∂Âà§Êñ≠' : 'ËäÇÁÇπ‰ªªÂä°'}`
          }
        ]);
        setCurrentStep(prev => prev + 1);
      }
    }
  };

  return (
    <Layout className="process-designer-container">
      <Sider width={200} theme="light">
        <div className="lf-dnd-panel">
          <h3>ÊµÅÁ®ãËäÇÁÇπ</h3>
          {nodeTypes.map(node => (
            <div
              key={node.type}
              className="lf-dnd-item"
              data-type={node.type}
            >
              <span className="node-icon">{node.icon}</span>
              <span>{node.label}</span>
            </div>
          ))}
        </div>
      </Sider>
      <Layout className='process-designer-content'>
        <Card
          bodyStyle={{ padding: '8px 16px' }}
          style={{ marginBottom: '8px' }}
          extra={
            <Space>
              <Button icon={<UndoOutlined />} onClick={handleUndo} />
              <Button icon={<RedoOutlined />} onClick={handleRedo} />
              <Button icon={<ZoomInOutlined />} onClick={handleZoomIn} />
              <Button icon={<ZoomOutOutlined />} onClick={handleZoomOut} />
              <Button icon={<OneToOneOutlined />} onClick={handleResetZoom} />
              <Button icon={<ImportOutlined />} onClick={handleImport} />
              <Button icon={<ExportOutlined />} onClick={handleExport} />
              <Button icon={<PlayCircleOutlined />} onClick={handleStartSimulation}>
                Ê®°ÊãüËøêË°å
              </Button>
              <Button type="primary" icon={<SaveOutlined />} onClick={handleSave}>
                ‰øùÂ≠ò
              </Button>
            </Space>
          }
        />
        <Content style={{ flex: 1, position: 'relative' }}>
          <div id="process-designer" style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0 }} />
        </Content>
      </Layout>

      <Modal
        title="ËäÇÁÇπÈÖçÁΩÆ"
        open={nodeModalVisible}
        onOk={() => nodeForm.submit()}
        onCancel={() => setNodeModalVisible(false)}
        className="process-designer-modal"
      >
        <Form
          form={nodeForm}
          layout="vertical"
          onFinish={handleUpdateNode}
        >
          <Form.Item
            name="name"
            label="ËäÇÁÇπÂêçÁß∞"
            rules={[{ required: true, message: 'ËØ∑ËæìÂÖ•ËäÇÁÇπÂêçÁß∞' }]}
          >
            <Input />
          </Form.Item>

          {currentNode?.type === 'approval' && (
            <>
              <Form.Item
                name="assignee"
                label="ÂÆ°Êâπ‰∫∫"
                rules={[{ required: true, message: 'ËØ∑ÈÄâÊã©ÂÆ°Êâπ‰∫∫' }]}
              >
                <Select>
                  <Option value="user1">Âº†‰∏â</Option>
                  <Option value="user2">ÊùéÂõõ</Option>
                  <Option value="user3">Áéã‰∫î</Option>
                </Select>
              </Form.Item>
              <Form.Item
                name="dueDate"
                label="Êà™Ê≠¢Êó∂Èó¥"
              >
                <Input type="number" addonAfter="Â∞èÊó∂" />
              </Form.Item>
            </>
          )}

          {currentNode?.type === 'condition' && (
            <Form.Item
              name="condition"
              label="Êù°‰ª∂Ë°®ËææÂºè"
              rules={[{ required: true, message: 'ËØ∑ËæìÂÖ•Êù°‰ª∂Ë°®ËææÂºè' }]}
            >
              <Input.TextArea rows={4} placeholder="ËØ∑ËæìÂÖ•Êù°‰ª∂Ë°®ËææÂºèÔºå‰æãÂ¶ÇÔºöamount > 1000" />
            </Form.Item>
          )}
        </Form>
      </Modal>

      {/* Ê®°ÊãüËøêË°åÂØπËØùÊ°Ü */}
      <Modal
        title="ÊµÅÁ®ãÊ®°ÊãüËøêË°å"
        open={simulationVisible}
        onCancel={() => setSimulationVisible(false)}
        footer={[
          <Button key="close" onClick={() => setSimulationVisible(false)}>
            ÂÖ≥Èó≠
          </Button>
        ]}
        width={600}
        className="process-designer-modal"
      >
        <Steps
          direction="vertical"
          current={currentStep}
          items={simulationPath.map((item, index) => ({
            title: item.title,
            description: item.description,
            status: item.status,
            onClick: () => handleNodeSelect(item.node.id)
          }))}
        />
      </Modal>
    </Layout>
  );
};

export default ProcessDesigner; 